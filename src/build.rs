use std::{env, fs, path::PathBuf};

fn main() {
    // Re-run build script if config changes
    println!("cargo:rerun-if-changed=config.toml");

    // Load config file if present
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let config_path = manifest_dir.join("config.toml");

    #[derive(Debug, Default)]
    struct Config {
        width: Option<u32>,
        height: Option<u32>,
        title: Option<String>,
        // Simulation params
        scale: Option<f32>,
        z: Option<f32>,
        z_step: Option<f32>,
        force: Option<f32>,
        friction: Option<f32>,
        steps_per_frame: Option<u32>,
        spawn_count_factor: Option<f32>,
        fade: Option<f32>,
        color_mode: Option<String>,
        paused: Option<bool>,
        // Seeds
        noise_seed: Option<u32>,
        rng_seed: Option<u64>,
        // Screensaver behavior
        screensaver_hide_cursor: Option<bool>,
        exit_arm_delay_ms: Option<u32>,
    }

    // Minimal TOML parser via `toml` crate
    let user_cfg: Config = if config_path.exists() {
        let content = fs::read_to_string(&config_path)
            .unwrap_or_else(|_| String::new());
        parse_config(&content)
    } else {
        Config::default()
    };

    // Defaults mirroring current app behavior
    let width = user_cfg.width.unwrap_or(800);
    let height = user_cfg.height.unwrap_or(800);
    let title = user_cfg.title.unwrap_or_else(|| "Perlin Flow Particles".to_string());

    let scale = user_cfg.scale.unwrap_or(0.004);
    let z = user_cfg.z.unwrap_or(0.0);
    let z_step = user_cfg.z_step.unwrap_or(0.004);
    let force = user_cfg.force.unwrap_or(0.8);
    let friction = user_cfg.friction.unwrap_or(0.985);
    let steps_per_frame = user_cfg.steps_per_frame.unwrap_or(300);
    let spawn_count_factor = user_cfg.spawn_count_factor.unwrap_or(0.25);
    let fade = user_cfg.fade.unwrap_or(0.03);
    let color_mode = user_cfg
        .color_mode
        .unwrap_or_else(|| "Direction".to_string());
    let paused = user_cfg.paused.unwrap_or(false);

    let noise_seed = user_cfg.noise_seed.unwrap_or(42);
    let rng_seed = user_cfg.rng_seed.unwrap_or(123_456_789);

    let screensaver_hide_cursor = user_cfg.screensaver_hide_cursor.unwrap_or(true);
    let exit_arm_delay_ms = user_cfg.exit_arm_delay_ms.unwrap_or(500);

    // Validate some values (basic)
    let safe_width = if width == 0 { 800 } else { width };
    let safe_height = if height == 0 { 800 } else { height };
    let safe_color_mode = match color_mode.as_str() {
        "Direction" | "Age" | "Curl" => color_mode,
        _ => "Direction".to_string(),
    };

    // Generate Rust module
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let dest_path = out_dir.join("build_config.rs");

    let contents = format!(
        "// Auto-generated by build.rs. Do not edit by hand.\n\
         pub const WIDTH: u32 = {width};\n\
         pub const HEIGHT: u32 = {height};\n\
         pub const TITLE: &str = \"{title}\";\n\
         pub const SCALE: f32 = {scale}_f32;\n\
         pub const Z: f32 = {z}_f32;\n\
         pub const Z_STEP: f32 = {z_step}_f32;\n\
         pub const FORCE: f32 = {force}_f32;\n\
         pub const FRICTION: f32 = {friction}_f32;\n\
         pub const STEPS_PER_FRAME: u32 = {steps_per_frame};\n\
         pub const SPAWN_COUNT_FACTOR: f32 = {spawn_count_factor}_f32;\n\
         pub const FADE: f32 = {fade}_f32;\n\
         pub const COLOR_MODE_STR: &str = \"{color_mode}\";\n\
         pub const PAUSED: bool = {paused};\n\
         pub const NOISE_SEED: u32 = {noise_seed};\n\
         pub const RNG_SEED: u64 = {rng_seed};\n\
          pub const SCREENSAVER_HIDE_CURSOR: bool = {screensaver_hide_cursor};\n\
          pub const EXIT_ARM_DELAY_MS: u32 = {exit_arm_delay_ms};\n\
        ",
        width = safe_width,
        height = safe_height,
        title = escape_rust_string(&title),
        scale = scale,
        z = z,
        z_step = z_step,
        force = force,
        friction = friction,
        steps_per_frame = steps_per_frame,
        spawn_count_factor = spawn_count_factor,
        fade = fade,
        color_mode = safe_color_mode,
        paused = paused,
        noise_seed = noise_seed,
        rng_seed = rng_seed,
        screensaver_hide_cursor = screensaver_hide_cursor,
        exit_arm_delay_ms = exit_arm_delay_ms,
    );

    fs::write(dest_path, contents).expect("failed to write build_config.rs");
}

fn parse_config(toml_str: &str) -> Config {
    // Use toml crate to deserialize to a generic Table then map manually
    let value: toml::Value = match toml::from_str(toml_str) {
        Ok(v) => v,
        Err(_) => return Config::default(),
    };
    let mut cfg = Config::default();
    if let toml::Value::Table(table) = value {
        for (k, v) in table.into_iter() {
            match (k.as_str(), v) {
                ("width", toml::Value::Integer(i)) => cfg.width = u32::try_from(i).ok(),
                ("height", toml::Value::Integer(i)) => cfg.height = u32::try_from(i).ok(),
                ("title", toml::Value::String(s)) => cfg.title = Some(s),
                ("scale", toml::Value::Float(f)) => cfg.scale = Some(f as f32),
                ("z", toml::Value::Float(f)) => cfg.z = Some(f as f32),
                ("z_step", toml::Value::Float(f)) => cfg.z_step = Some(f as f32),
                ("force", toml::Value::Float(f)) => cfg.force = Some(f as f32),
                ("friction", toml::Value::Float(f)) => cfg.friction = Some(f as f32),
                ("steps_per_frame", toml::Value::Integer(i)) => cfg.steps_per_frame = u32::try_from(i).ok(),
                ("spawn_count_factor", toml::Value::Float(f)) => cfg.spawn_count_factor = Some(f as f32),
                ("fade", toml::Value::Float(f)) => cfg.fade = Some(f as f32),
                ("color_mode", toml::Value::String(s)) => cfg.color_mode = Some(s),
                ("paused", toml::Value::Boolean(b)) => cfg.paused = Some(b),
                ("noise_seed", toml::Value::Integer(i)) => cfg.noise_seed = u32::try_from(i).ok(),
                ("rng_seed", toml::Value::Integer(i)) => cfg.rng_seed = u64::try_from(i).ok(),
                ("screensaver_hide_cursor", toml::Value::Boolean(b)) => cfg.screensaver_hide_cursor = Some(b),
                ("exit_arm_delay_ms", toml::Value::Integer(i)) => cfg.exit_arm_delay_ms = u32::try_from(i).ok(),
                _ => {}
            }
        }
    }
    cfg
}

fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}


